import typing
import numpy as np
import numpy.typing as npt
from boundary_conditions import OnCircleBoundaryCondition, VertexBoundaryConditionsCollection, WorldDimension
from geometry import triangle_area_cross, MeshVertexCollection, MeshFaceCollection, MeshVertexConnectivity, Triangle, get_onering_neighbors, mesh_area


_XY_COLUMNS = np.tile(np.array([0, 1]), (3, 1))
_YZ_COLUMNS = np.tile(np.array([1, 2]), (3, 1))
_XZ_COLUMNS = np.tile(np.array([0, 2]), (3, 1))
_ROWS = np.arange(3)[:np.newaxis]

def _remap_triangle_to_local(condition: OnCircleBoundaryCondition, tri: Triangle) -> Triangle:
    return np.array([condition.remap_to_circle_coordinates(pt) for pt in tri])

def _remap_triangle_to_global(condition: OnCircleBoundaryCondition, tri: Triangle) -> Triangle:
    return np.array([condition.remap_to_global_coordinates(pt) for pt in tri])

def _reduce_triangle_dimension(tri: Triangle, dimension: WorldDimension) -> npt.NDArray[np.float64]:
    """
    Reduce the given dimension of a triangle. This will erase the specified
    dimension from all triangle corners, re-defining it as a 2-dimensional triangle
    """

    columns = None
    if dimension == WorldDimension.X:
        columns = _YZ_COLUMNS
    elif dimension == WorldDimension.Y:
        columns = _XZ_COLUMNS
    elif dimension == WorldDimension.Z:
        columns = _XY_COLUMNS

    return tri[_ROWS, columns]

def _select_triangle_dimension(tri: Triangle, dimension: WorldDimension) -> npt.NDArray[np.float64]:
    """
    Select a single dimension of a triangle to condense it to.
    This will reduce the triangle to an array of 3 scalars.
    """
    if dimension == WorldDimension.X:
        return tri[:,0]
    elif dimension == WorldDimension.Y:
        return tri[:,1]
    elif dimension == WorldDimension.Z:
        return tri[:,2]

def _calc_tri_c_1d(tri: Triangle) -> npt.NDArray[np.float64]:
    # we know that triangles are generated by lookup,
    # and the first vertex is always the one that the lookup
    # was generated for. So in this case,
    # 0 -> Ph, 1 -> Pj, 2 -> Pk
    h, j, k = tri

    # pre-compute the two vectors we will be using
    jk = k - j
    jk2 = jk**2

    top = jk2 * (1 - jk2)

    jh = h - j
    bottom = 0.5 * jk * jh
    
    return top / bottom


def _calc_tri_c_2d(tri: Triangle) -> npt.NDArray[np.float64]:
    """
    Calc the intermediate 'C' value according to the simplification.
    Output should be a 2x2 matrix
    """

    # we know that triangles are generated by lookup,
    # and the first vertex is always the one that the lookup
    # was generated for. So in this case,
    # 0 -> Ph, 1 -> Pj, 2 -> Pk
    h, j, k = tri

    # pre-compute the two vectors we will be using
    jk = k - j

    top = jk.dot(jk) * np.eye(2) - (np.transpose(np.matrix(jk)) @ np.matrix(jk))

    bottom = triangle_area_cross(tri)

    return top / bottom

def _calc_tri_c(tri: Triangle) -> npt.NDArray[np.float64]:
    """
    Calc the intermediate 'C' value according to the simplification.
    Output should be a 3x3 matrix
    """

    # we know that triangles are generated by lookup,
    # and the first vertex is always the one that the lookup
    # was generated for. So in this case,
    # 0 -> Ph, 1 -> Pj, 2 -> Pk
    h, j, k = tri

    # pre-compute the two vectors we will be using
    jk = k - j
    # jh = h - j

    top = jk.dot(jk) * np.eye(3) - (np.transpose(np.matrix(jk)) @ np.matrix(jk))

    # print("Calculating c value...")
    # print(f"h: {h}, j: {j}, k: {k}")
    # print(f"jk: {jk}, jh: {jh}")

    # bottom = np.sqrt(np.cross(jk, jh)**2)
    bottom = triangle_area_cross(tri)

    # print(f"top is {top}, bottom is {bottom}")

    # return top
    return top / bottom

def _calc_tri_area_derivative(tri: Triangle) -> npt.NDArray[np.float64]:
    """
    Calculate the area derivative of the given triangle.
    Output should be a 3x1 vector
    """

    h, j, k = tri
    jk = k - j
    # jh = h - j

    # print("Calculating area derivative...")

    top = np.dot(jk, j) * jk - jk.dot(jk) * j
    # bottom = np.sqrt(np.cross(jk, jh)**2)
    bottom = triangle_area_cross(tri)

    # print(f"top is {top}, bottom is {bottom}")

    # return top
    return top / bottom

def minimize_mesh(
    vertices: MeshVertexCollection,
    faces: MeshFaceCollection,
    connectivity: MeshVertexConnectivity,
    tolerance: float,
    max_iterations: typing.Union[float, None],
    boundary_conditions: VertexBoundaryConditionsCollection
    ) -> MeshVertexCollection:
    """
    Minimize the vertex positions of the given mesh,
    so that the total area of the mesh is minimal.
    """

    # TODO: Think about ways to speed this up

    # TODO: Figure out the math used fully for documentation

    if max_iterations is None:
        max_iterations = 10

    old_vertices = np.copy(vertices)
    new_vertices = np.copy(vertices)

    constrained_indices = [i for i in boundary_conditions]
    change_base_indices = [i for i in boundary_conditions if any([type(condition) == OnCircleBoundaryCondition for condition in boundary_conditions[i]])]

    for iter in range(max_iterations):

        # iterate over all vertices
        for i, vertex in enumerate(old_vertices):

            is_constrained = i in constrained_indices

            # if it is an anchor vertex, we don't need to do anything
            if is_constrained:
                if any([condition.is_fully_constrained() for condition in boundary_conditions[i]]):
                    new_vertices[i] = vertex
                    continue

            # get the one-ring neighbors of the current vertex
            neighbors = get_onering_neighbors(i, old_vertices, connectivity)

            # TODO: After getting the onering neighbors, we have to check if we have 
            # a boundary condition where we have to transform all coordinates to a different
            # plane (f.e. OnCurve) and do that before doing the calculations...
            needs_transform = i in change_base_indices
            remap_condition: OnCircleBoundaryCondition
            if needs_transform:
                # TODO: Just grabbing the first condition is lazy...
                remap_condition = [condition for condition in boundary_conditions[i] if type(condition) == OnCircleBoundaryCondition][0]

                neighbors = np.array([_remap_triangle_to_local(remap_condition, tri) for tri in neighbors])

            # print(f"neighbors are: {neighbors}")

            # calculate the c values for all the one-ring faces to get 'C'
            c = np.sum(np.array([_calc_tri_c(tri) for tri in neighbors]), axis=0)
            p = np.sum(np.array([_calc_tri_area_derivative(tri) for tri in neighbors]), axis=0)

            # print(f"c is {c}, p is {p}")

            # have to use dot product here because numpy treats '*' as element-wise by default
            if np.linalg.det(c) == 0:
                print(f"singular matrix {c} for vertex {i}, skipping...")
                new_vertices[i] = vertex
                continue
            p_new = -np.linalg.inv(c).dot(p)

            # enforce the boundary conditions on the new point
            # TODO: Instead of enforcing here, we should rather optimize the calculation
            # so it uses only the dimensions of the point that are unconstrained
            if is_constrained:
                for condition in boundary_conditions[i]:
                    p_new = condition.enforce(p_new)

            if needs_transform:
                # print(f"remapping local point {p_new}")
                p_new = remap_condition.remap_to_global_coordinates(p_new)
                # print(f"remapped to global: {p_new}")

            # print(f"calculated new position for {vertex} -> {p_new}")
            new_vertices[i] = p_new

        # calc the triangle area
        old_area = mesh_area(old_vertices, faces)
        new_area = mesh_area(new_vertices, faces)
        if np.abs(old_area - new_area) <= tolerance:
            print(f"Early exit after {iter} iterations. Area difference was {old_area - new_area}")
            return new_vertices

        # swap the buffers and run next loop
        (old_vertices, new_vertices) = (new_vertices, old_vertices)

        print(f"Finished iteration {iter}")

    return old_vertices


